#+TITLE: config.org
#+AUTHOR: Deftpunk
#+STARTUP: content
#+OPTIONS: toc:4 :num:nil ^:nil
* UI

Most of the UI configuration takes place in =core/core-ui.el=, this includes setting up the
modeline, fonts and themes.  This section is for extraneous highlighting and fancy display
like that.

** beacon

[[https://github.com/Malabarba/beacon][Never lose your cursor again]] - Whenever the window scrolls a light will shine
on top of your cursor so you know where it is.

#+begin_src emacs-lisp :name beacon
  (use-package beacon
    :config
    (beacon-mode 1))
#+end_src

** Highlight cl-lib

[[https://github.com/skeeto/cl-lib-highlight][cli-lib-highlight]] - Syntax highlighting for cl-lib, so that =cl-loop=,
=cl-defun=, =cl-defstruct= and the like get highlighted

#+BEGIN_SRC emacs-lisp :name cl-lib-highlight
  (use-package cl-lib-highlight
    :config
    (cl-lib-highlight-initialize))
#+END_SRC

** Highlight Escape sequences

[[https://github.com/dgutov/highlight-escape-sequences/blob/master/highlight-escape-sequences.el][highlight-escape-sequences]] - what the title says.

#+begin_src emacs-lisp :name highlight-escape
  (use-package highlight-escape-sequences
    :defer t
    :init
    (add-hook 'prog-mode-hook #'hes-mode)
    :config
    (put 'hes-escape-backslash-face 'face-alias 'font-lock-builtin-face)
    (put 'hes-escape-sequence-face 'face-alias 'font-lock-builtin-face))
#+end_src

** Highlight Numbers

[[https://github.com/Fanael/highlight-numbers][highlight-numbers]] - Highlight numeric literals in source code.

#+begin_src emacs-lisp :name highlight-numbers
  (use-package highlight-numbers
    :defer t
    :init (add-hook 'prog-mode-hook #'highlight-numbers-mode))
#+end_src

** Highlight Quotes

[[https://github.com/Fanael/highlight-quoted][highlight-quoted]] - Highlight Lisp quotes and quoted symbols

#+begin_src emacs-lisp :name highlight-quoted
  (use-package highlight-quoted
    :defer t
    :config
    (add-hook 'emacs-lisp-mode-hook 'highlight-quoted-mode))
#+end_src

** Highlight Symbols

[[https://github.com/gennad/auto-highlight-symbol][highlight-symbol]] - Highlight the symbol under point.

#+begin_src emacs-lisp :name highlight-symbol
    (use-package auto-highlight-symbol
      :defer t
      :init
      (setq ahs-case-fold-search nil
            ahs-default-range 'ahs-range-whole-buffer
            ahs-idle-interval 0.25
            ahs-inhibit-face-list nil)
      ;; but a box around the face.
      (custom-set-faces `(ahs-face ((t (:box t)))))
      (custom-set-faces `(ahs-definition-face ((t (:box t)))))
      (custom-set-faces `(ahs-plugin-whole-buffer-face ((t (:box t)))))
      :config
      (add-hook 'prog-mode-hook 'auto-highlight-symbol-mode))
#+end_src

** Volatile highlights

[[https://www.emacswiki.org/emacs/VolatileHighlights][Volatile highlights]] - temporarily highlights changes to the buffer associated with certain commands that
add blocks of text at once. An example is that if you paste (yank) a block of text, it will be
highlighted until you press the next key.

#+begin_src emacs-lisp :naame volatile-highlights
  (use-package volatile-highlights
    :config
    (volatile-highlights-mode 1))

  ;; Support evil-mode
  (vhl/define-extension 'evil 'evil-paste-after 'evil-paste-before
                        'evil-paste-pop 'evil-move)
  (vhl/install-extension 'evil)

  ;; Supporting undo-tree.
  (vhl/define-extension 'undo-tree 'undo-tree-yank 'undo-tree-move)
  (vhl/install-extension 'undo-tree)
#+end_src

* Editor
** Editor Settings

#+BEGIN_SRC emacs-lisp :name EditorSettings
  (setq-default
   ;; abbreviations
   abbrev-file-name (expand-file-name "abbrev_defs" user-emacs-directory)
   default-abbrev-mode t
   save-abbrevs 'silently
   ;; bookmarks
   bookmark-default-file (concat flex-etc-dir "bookmarks")
   bookmark-version-control t
   bookmark-save-flag t
   ;; Formatting
   delete-trailing-lines nil
   fill-column 105
   sentence-end-double-space nil
   word-wrap t
   ;; Scrolling
   hscroll-margin 1
   hscroll-step 1
   scroll-conservatively 1001
   scroll-margin 0
   scroll-preserve-screen-position t
   mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))) ;make mouse scrolling smooth
   ;; Whitespace - the other religous war.  use whitespace NOT tabs.
   tab-width 4
   indent-tabs-mode nil
   c-basic-offset 4
   require-final-newline t
   tabify-regexp "^\t* [ \t]+" ; for :retab
   ;; whitespace-mode
   whitespace-line-column fill-column
   whitespace-style '(face indentation tabs tab-mark spaces space-mark newline newline-mark
                           trailing lines-tail)
   whitespace-display-mappings '((tab-mark ?\t [?› ?\t])
                                 (newline-mark ?\n [?¬ ?\n])
                                 (space-mark ?\  [?·] [?.]))
   ;; Wrapping
   truncate-lines t
   truncate-partial-width-windows 50
   )

  ;;; Turn on flyspell for programming modes
  (add-hook 'prog-mode-hook #'flyspell-prog-mode)

  ;; auto-fill comments in prog-mode derived modes.
  ;; this only works for programming modes that define a comment syntax; the
  ;; syntax is not adapting, e.g. 3 semi-colons starting a comment is not carried
  ;; forward to the next line.
  (defun flex-emacs:prog-auto-fill-comments ()
    "I want auto-filling of comments like that Other Editor"
    (interactive)
    (set (make-local-variable 'comment-auto-fill-only-comments) t)
    (set (make-local-variable 'fill-column) 79)
    (auto-fill-mode t))
  (add-hook 'prog-mode-hook #'flex-emacs:prog-auto-fill-comments)

  ;; column-number-mode
  ;; Display the column number in the modeline
  (column-number-mode 1)

  ;; Delete regions using the *Delete* key.
  (delete-selection-mode 1)

  ;; ediff
  ;; magit + ediff - Use the two together to resolve merge conflicts.
  ;; https://coderwall.com/p/mcrwag/use-magit-ediff-to-resolve-merge-conflicts
  (setq ediff-diff-options "-w"
        ediff-use-long-help-message 1
        ediff-split-window-function #'split-window-horizontally
        ediff-window-setup-function #'ediff-setup-windows-plain)
                                          ; Run winner undo afterwards in an attempt to get back to some "sane" window layout.
  (add-hook 'ediff-after-quit-hook-internal #'winner-undo)

  ;; recentf
  ;; Keep track of recently opened files
  (setq recentf-save-file (concat flex-cache-dir "recentf")
        recentf-max-menu-items 0
        recentf-max-saved-items 300
        recentf-filename-handlers '(file-truename)
        recentf-exclude
        (list "^/tmp/" "^/ssh:" "\\.?ido\\.last$" "\\.revive$" "/TAGS$"
              "^/var/folders/.+$"
              ;; ignore private temp files (but not all of them)
              (concat "^" (file-truename flex-local-dir))))
  (add-hook! 'flex-init-hook #'recentf-mode)

  ;; revert buffers for changed files
  (global-auto-revert-mode 1)
  (setq auto-revert-verbose nil)

  ;; savehist / saveplace
  (setq savehist-file (concat flex-cache-dir "savehist")
                                          ; keep emacs from being slow to exit after enabling saveplace.
        save-place-forget-unreadable-files nil
        savehist-save-minibuffer-history t
        savehist-autosave-interval nil ; save on kill only
        savehist-additional-variables '(kill-ring search-ring regexp-search-ring)
        save-place-file (concat flex-cache-dir "saveplace"))
  (add-hook! 'flex-init-hook #'(savehist-mode save-place-mode))

  ;; More dealing with whitespace.
  (add-hook 'prog-mode-hook '(lambda ()
                               (setq show-trailing-whitespace 1)))
  ;; Delete trailing whitespace just before saving.
  (add-hook 'before-save-hook 'delete-trailing-whitespace)

     ;;;
     ;;; Advising and hooking.
     ;;;
     ;;; Functions used are from core/autoload/

  ;; Quit.
  (advice-add #'quit-window :around #'flex*quit-window)

  ;; We don't want to even bury the *scratch* buffer.
  (add-hook 'kill-buffer-query-functions #'flex|dont-kill-scratch-buffer)

#+END_SRC

*** Dired

Directory listing in Emacs.

#+begin_src emacs-lisp :name Dired
  ;; Omit the . and .. files cuz we can go up a directory other ways.
  (setq-default dired-omit-mode t
                dired-omit-verbose nil
                dired-omit-files "^\\.$\\|^\\.\\.$")

  ;; Use gls on a Mac
  (when IS-MAC
    (if (executable-find "gls")
        (progn
          (setq insert-directory-program "gls")
          (setq dired-listing-switches "-lFaGh1v --group-directories-first"))
      (setq dired-listing-switches "-ahlF")))
#+end_src

**** dired-subtree

[[https://github.com/Fuco1/dired-hacks#dired-subtree][dired-subtree]] - Show subtree under directory in dired

#+begin_src emacs-lisp :name dired-subtree
(use-package dired-subtree
  :config
  (bind-keys :map dired-mode-map
             ("i" . dired-subtree-insert)
             (";" . dired-subtree-remove)))
#+end_src

**** WDired

Writeable Dired - Edit a Dired buffer just like any other bother using a binding.

Mastering Emacs has a good article on its configuration and usage - [[https://masteringemacs.org/article/wdired-editable-dired-buffers][WDired]]

#+begin_src emacs-lisp :name wdired
  (use-package wdired
    :init
    (setq wdired-allow-to-change-permissions t
          wdired-use-interactive-rename t
          wdired-confirm-overwrite t
          wdired-use-dired-vertical-movement t))
#+end_src

**** peep-dired

[[https://github.com/asok/peep-dired][peep-dired]] - Preview files from dired.

#+begin_src emacs-lisp :name peep-dired
  (use-package peep-dired
    :ensure t
    :defer t
    :bind (:map dired-mode-map
                ("P" . peep-dired))
    :init
    (setq peep-dired-cleanup-on-disable t
          peep-dired-cleanup-eagerly t
          peep-dired-enable-on-directories t
          peep-dired-ignored-extensions '("mkv" "iso" "mp4" "pyc")))
#+end_src

*** Shells & Terminals

    Another possible fix for term/zsh problems if they occur - https://stackoverflow.com/questions/8918910/weird-character-zsh-in-emacs-terminal
    Found a fix for the term+zsh problem - https://www.reddit.com/r/emacs/comments/5p3njk/help_terminal_zsh_control_characters_in_prompt/

#+BEGIN_SRC emacs-lisp :name terminals
  (use-package ansi-color
    :commands ansi-color-for-comint-mode-on
    :init
    (progn
      (setq comint-scroll-to-bottom-on-input t
            comint-scroll-to-bottom-on-output t
            comint-scroll-show-maximum-output t
            comint-completion-autolist t
            comint-input-ignoredups t
            comint-completion-addsuffix t
            comint-promp-read-only nil
            comint-completion-recexact nil
            comint-buffer-maximum-size 100000
            comint-input-ring-size 5000
            term-default-bg-color "#080808"
            term-default-fg-color "#00ff00"
            comint-get-old-input (lambda () "")))
    :config
    (progn
      (add-hook 'term-mode-hook
            #'(lambda ()
            (yas-minor-mode -1)  ; interferes w/ Tab
            ;(autopair-mode -1)   ; interferes w/ Return
            (setq term-mode-buffer-maximum-size 10000
              show-trailing-whitespace nil)))

      (use-package multi-term
        :ensure multi-term
        :init
        (progn
      (add-hook 'term-mode-hook
            (lambda ()
              (yas-minor-mode -1)
              ;(autopair-mode -1)
              (setq term-buffer-maximum-size 10000
                show-trailing-whitespace nil)))
      (setq multi-term-program "/bin/bash"
            multi-term-switch-after-close nil
            term-bind-key-alist '(("C-c C-c" . term-interrupt-subjob)
                      ("M-p" . previous-line)
                      ("M-n" . next-line)
                      ("C-s" . isearch-forward)
                      ("C-r" . term-send-reverse-search-history)
                      ("C-m" . term-send-raw)
                      ("M-f" . term-send-forward-word)
                      ("M-b" . term-send-backward-word)
                      ("M-o" . term-send-backspace)
                      ([backspace] . term-send-backspace)
                      ("<RETURN>" . term-send-raw)
                      ([del] . term-send-del)
                      ("C-d" . term-send-eof)
                      ([home] . term-send-home)
                      ("C-a" . term-send-home)
                      ([end] . term-send-end)
                      ("C-e" . term-send-end)
                      ("M-h" . windmove-left)
                      ("M-j" . windmove-down)
                      ("M-k" . windmove-up)
                      ("M-l" . windmove-right)
                      ("M-x" . execute-extended-command)
                      ("C-p" . term-send-up)
                      ("C-n" . term-send-down)
                      ("M-M" . term-send-forward-kill-word)
                      ("C-w" . term-send-backward-kill-word)
                      ("M-r" . term-send-reverse-search-history)
                      ("M-," . term-send-input)
                      ("M-." . comint-dynamic-complete)))))))
#+END_SRC

** Editor Modes

Things from the intertubes that improve upon Emacs the editor, e.g. completion, navigation, etc.

*** ace-link

[[https://github.com/abo-abo/ace-link][ace-link]] - Select a link to jump to in Info, help, woman, org or eww modes

#+begin_src emacs-lisp :name ace-link
  (use-package ace-link
    :commands (ace-link-help ace-link-org ace-link-setup-default)
    :init (ace-link-setup-default))
#+end_src

*** ace-window

[[https://github.com/abo-abo/ace-window][ace-window]] - Selecting a window to switch to

#+begin_src emacs-lisp :name ace-window
(use-package ace-window
  :config
  (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l)
	aw-leading-char-style 'path)
  (set-face-attribute 'aw-leading-char-face nil :height 3.0))
#+end_src

*** aggressive-indent-mode

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent-mode]] - keep your code nicely aligned while you type.

#+begin_src emacs-lisp :name aggressive-indent-mode
    (use-package aggressive-indent
      :config
      (add-hook! 'prog-mode-hook #'aggressive-indent-mode))
#+end_src

*** bookmarks+

#+begin_src emacs-lisp :name bookmarks
  (use-package bookmark+
    :defer t
    :load-path "emacswikilibs/bookmark-plus/")
#+end_src

*** Counsel, Avy, Ivy, Swiper

[[https://github.com/abo-abo/swiper][avy, ivy, counsel and swiper]] - avy, ivy, counsel and swiper from the great abo-abo,
who also came up with hydra.

- Ivy, a generic completion mechanism for Emacs.
- Counsel, a collection of Ivy-enhanced versions of common Emacs commands.
- Swiper, an Ivy-enhanced alternative to isearch.

Turning on counsel-mode to see remaps of Emacs commands
- https://github.com/abo-abo/swiper#user-content-counsel

#+BEGIN_SRC emacs-lisp :name counsel-swiper
  (use-package avy
    :commands (avy-goto-char-2 avy-goto-line)
    :config
    (setq avy-all-windows nil
          avy-background t))

  (use-package counsel
    :commands counsel-mode
    :bind (:map ivy-minibuffer-map
                ([escape] . minibuffer-keyboard-quit))
    :init
    (setq counsel-rg-base-command
          "rg -i -M 120 --no-heading --line-number --color never %s .")
    :config
    (counsel-mode 1)
  )

  (load "counsel-autoloads" nil nil) ; we really want everything available.

  (use-package swiper
    :commands (swiper)
    :bind (:map ivy-minibuffer-map
                ("C-w" . ivy-backward-kill-word)
                ("C-y" . ivy-yank-word)
                ([escape] . minibuffer-keyboard-quit))
    :init
    (setq ivy-wrap t     ; make ivy-next-line & ivy-previous-line cycle around.
          ivy-height 25  ; make the minibuffer just a little taller.
          ivy-use-virtual-buffers t
          ivy-count-format "%d/%d"
          )
    :config
    (ivy-mode 1))

  (use-package ivy-rich
    :ensure t
    :after (ivy)
    :init
    (setq ivy-rich-path-style 'abbrev
          ivy-virtual-abbreviate 'full)
    :config (ivy-rich-mode 1))
#+END_SRC

*** easy-kill

[[https://github.com/leoliu/easy-kill][easy-kill]] kill or mark things easily

#+BEGIN_SRC emacs-lisp :name easy-kill
(use-package easy-kill
  :defer t)
#+END_SRC

*** expand-region

#+BEGIN_SRC emacs-lisp :name expand-region
(use-package expand-region
  :commands (er/expand-region er/contract-region er/mark-symbol er/mark-word))
#+END_SRC

*** goto-chg

[[https://github.com/emacs-evil/goto-chg][goto-chg]] - Go to the last change in the buffer.

#+begin_src emacs-lisp :name goto-chg
(use-package goto-chg)
#+end_src

*** Helm

#+BEGIN_SRC emacs-lisp :name Helm
(use-package helm
  :commands (helm-mini helm-M-x)
    :bind (:map helm-map
              ([escape] . helm-keyboard-quit))
  :init
  (setq helm-idle-delay                        1.0    ; Update fast sources immediately (doesn't).
        helm-input-idle-delay                  0.01   ; This actually updates things reeeelatively quickly.
        helm-quick-update                      t
        helm-M-x-requires-pattern              nil
        helm-candidate-number-limit            99     ; Setting this above 100 will slow down fuzzy matching
        helm-autoresize-max-height             45     ; Set the max window height to 45% of current frame.
        helm-mode-fuzzy-match                  t      ; Turn on fuzzy matching for buffers, semantic, recentf
        helm-completion-in-region-fuzzy-match  t      ; Completion, imenu, apropos, M-x
        helm-buffer-skip-remote-checking       t      ; Ignore checking if file exists on remote files, ie. Tramp
        helm-tramp-verbose                     6      ; See Tramp messages in helm
        helm-ff-skip-boring-files              t)
  :config
  (load "helm-autoloads" nil t)
  (add-hook 'flex-init-hook #'helm-mode)

  ;; helm is too heavy for find-file-at-point
  (after! helm-mode
    (add-to-list 'helm-completing-read-handlers-alist '(find-file-at-point . nil)))
  )


#+END_SRC

*** Help Mode Helpers

Some packages and utilities to help with Help Mode

# TODO: fix the keybindings in this section.

**** finder

Adds a neat way to look at just the Commentary section - http://irreal.org/blog/?p=6248

#+begin_src emacs-lisp :name finder
  (use-package finder
    :bind (
           :map help-mode-map
           ("C-c" . finder-commentary)
           ("C-l" . find-library)))
#+end_src

**** help+

[[https://www.emacswiki.org/emacs/help+.el][help+]]

The following bindings are made here:

   `C-h u'      `manual-entry'
   `C-h C-a'    `apropos'
   `C-h C-l'    `locate-library'
   `C-h RET'    `help-on-click/key'
   `C-h M-a'    `apropos-documentation'
   `C-h M-o'    `pop-to-help-toggle'
   `C-h C-M-a'  `tags-apropos'
   [mouse-1]    `mouse-help-on-click' (non-mode-line)
   [mouse-1]    `mouse-help-on-mode-line-click' (mode-line)

#+begin_src emacs-lisp :name help-plus
  (use-package help+
    :load-path "emacswikilibs/help-plus/")
#+end_src

**** help-fns

[[https://www.emacswiki.org/emacs/help-fns+.el][help-fns]]

Keys bound here:

   `C-h B'      `describe-buffer'
   `C-h c'      `describe-command'     (replaces `describe-key-briefly')
   `C-h o'      `describe-option'
   `C-h C-c'    `describe-key-briefly' (replaces `C-h c')
   `C-h C-o'    `describe-option-of-type'
   `C-h M-c'    `describe-copying'     (replaces `C-h C-c')
   `C-h M-f'    `describe-file'
   `C-h M-k'    `describe-keymap'
   `C-h M-l'    `find-function-on-key'

#+BEGIN_SRC emacs-lisp :name help-fns
(use-package help-fns+
  :load-path "emacswikilibs/help-fns-plus/")
#+END_SRC

*** hl-todo

[[https://github.com/tarsius/hl-todo][hl-todo]] - Highlight TODO and similar keywords in comments and strings.
By default it is only active in modes that derive from prog-mode.  It is a
dependency for =magit-hl-todos= which toggles in =magit-status=.

#+BEGIN_SRC emacs-lisp :name hl-todo
(use-package hl-todo)
(add-hook 'prog-mode-hook 'hl-todo-mode)
#+END_SRC

*** list-environment

[[https://github.com/dgtized/list-environment.el][list-environment]] - List out the current environment variables.  You can also
modify them in the *Process Environment* buffer.  =M-x list-environment=

#+begin_src emacs-lisp :name list-environment
  (use-package list-environment
    :defer t)
#+end_src

*** move-text

[[https://github.com/emacsfodder/move-text][move-text]] - Move region or current line up or down.

#+BEGIN_SRC emacs-lisp :name move-text
(use-package move-text
  :commands (move-text-up move-text-down))
#+END_SRC

*** Persistent Scratch
[[https://github.com/Fanael/persistent-scratch][
persistent-scratch]] is an Emacs package that preserves the state of scratch buffers across
Emacs sessions by saving the state to and restoring it from a file.

#+begin_src emacs-lisp :name persistent-scratch
(use-package persistent-scratch
  :commands (persistent-scratch-setup-default)
  :init
  ;;(setq initial-major-mode 'emacs-lisp-mode)
  (setq persistent-scratch-save-file (expand-file-name "persistent-scratch" flex-etc-dir))
  :config
  (persistent-scratch-setup-default))
#+end_src

*** Projectile

[[https://github.com/bbatsov/projectile][Projectile]] for sane project management.

#+begin_src emacs-lisp :name Projectile
  (use-package projectile
    :defer t
    :commands (projectile--mode projectile-project-root)
    :init
    (add-hook 'after-init-hook 'projectile--mode)
    ;; Move cache files to .local
    (setq projectile-cache-file (expand-file-name "projectile.cache" flex-cache-dir)
          projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" flex-cache-dir))
    :config
    (setq projectile-globally-ignored-file-suffixes '("*.pyc"  "*.class"))
    (setq projectile-completion-system 'ivy
          projectile-enable-caching t
          projectile-use-git-grep t
          ;; projectile-indexing-method 'native
          projectile-remember-window-configs t
          projectile-switch-project-action 'projectile-find-file)
    (add-to-list 'projectile-globally-ignored-files ".DS_Store")
    (add-to-list 'projectile-globally-ignored-files "*.i")
    (setq projectile-globally-ignored-directories
          (append projectile-globally-ignored-directories '(".git"
                                                            ".hg"
                                                            ".cache"
                                                            "__pycache__"
                                                            ".mypy_cache"
                                                            "elpa")))
    )
#+end_src

    :defer t
**** counsel-projectile

[[https://github.com/ericdanan/counsel-projectile][counsel-projectile]]

#+BEGIN_SRC emacs-lisp :name counsel-projectile
  (use-package counsel-projectile
    )
#+END_SRC

*** Quickrun

[[https://github.com/syohex/emacs-quickrun][Quickrun]] - Run command quickly. This packages is inspired quickrun.vim

#+begin_src emacs-lisp :name quickrun
  (use-package quickrun
    :commands (quickrun
               quickrun-region
               quickrun-with-arg
               quickrun-shell
               quickrun-compile-only
               quickrun-replace-region))
#+end_src

*** Rainbow Delimiters

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] - rainbow parenthesis

#+begin_src emacs-lisp :name rainbow-delimiters
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

*** Rainbow mode

[[https://julien.danjou.info/projects/emacs-packages][rainbow-mode]] - Show hex codes as their actual color.

#+begin_src emacs-lisp :name rainbow-mode
  (use-package rainbow-mode
    :defer t
    :commands rainbow-turn-on
    :init
    (add-hook 'prog-mode-hook 'rainbow-turn-on)
    :config
    (setq rainbow-x-colors nil))
#+end_src

*** Smartparens

[[https://github.com/Fuco1/smartparens][smartparens]] - deals with parens pairs and tries to be smart about it.

A [[https://ebzzry.github.io/emacs-pairs.html][great article]] showing how to use it effectively, extensive documentation
in the [[https://github.com/Fuco1/smartparens/wiki][wiki]] and a [[https://www.reddit.com/r/emacs/comments/38k1j5/paredit_smartparens_autopair/][reddit article]] with comparisons to autopair, paredit & lispy.

#+BEGIN_SRC emacs-lisp :name smartparens
(use-package smartparens
  :hook (flex-init . smartparens-global-mode)
  :config
  (require 'smartparens-config)

  (setq sp-autowrap-region nil ; let evil-surround handle this
        sp-highlight-pair-overlay nil
        sp-cancel-autoskip-on-backward-movement nil
        sp-show-pair-delay 0
        sp-max-pair-length 3)

  ;; disable smartparens in evil-mode's replace state (they conflict)
  (add-hook 'evil-replace-state-entry-hook #'turn-off-smartparens-mode)
  (add-hook 'evil-replace-state-exit-hook  #'turn-on-smartparens-mode)

  (sp-local-pair '(xml-mode nxml-mode php-mode) "<!--" "-->"
                 :post-handlers '(("| " "SPC"))))
#+END_SRC

*** Super Save

[[https://github.com/bbatsov/super-save][super-save]] - An auto-saving library.
https://emacsredux.com/blog/2018/09/29/super-save-0-dot-3/

#+BEGIN_SRC emacs-lisp :name super-save
(use-package super-save
  :commands (super-save-mode super-save-triggers super-save-hook-triggers)
  :init
  (setq super-save-remote-files nil)
  :config
  (add-to-list 'super-save-triggers 'ace-window)
  (add-to-list 'super-save-hook-triggers 'find-file-hook)
  (super-save-mode +1))
#+END_SRC

*** Undo Tree

[[https://www.emacswiki.org/emacs/UndoTree][Undo Tree]] - Make undo something more like the undo/redo you get in other
editors.  There is also =undo-tree-visualize= that allows you to visually
walk through the changes that you have made.

There are a couple of bugs because of changes(?) in Emacs 26.x :
https://old.reddit.com/r/emacs/comments/85t95p/undo_tree_unrecognized_entry_in_undo_list/
https://www.reddit.com/r/emacs/comments/9zxnvm/undotreevisualize_super_slow/

#+begin_src emacs-lisp :name undo-tree
(use-package undo-tree
  :commands (undo-tree-redo)
  :init
  (setq undo-tree-enable-undo-in-region nil)
  :config
  (add-hook 'flex-init-hook #'global-undo-tree-mode)
  ;; persistent undo history is known to cause undo history corruption, which
  ;; can be very destructive! So disable it!
  (setq undo-tree-auto-save-history nil
	    undo-tree-visualizer-timestamps t
	    undo-tree-visualizer-diff t
        undo-tree-history-directory-alist
        (list (cons "." (concat flex-cache-dir "undo-tree-hist/")))))
#+end_src

*** vimish folds

https://github.com/mrkkrp/vimish-fold Vim-like text folding for Emacs.

This is a package to perform text folding like in Vim. It has the following features:

  - folding of active regions;
  - good visual feedback: it's obvious which part of text is folded;
  - persistence by default: when you kill a buffer your folds don't disappear;
  - persistence scales well, you can work on hundreds of files with lots of folds
    without adverse effects;
  - it does not break indentation;
  - folds can be toggled from folded state to unfolded and back very easily;
  - quick navigation between existing folds;
  - you can use mouse to unfold folds (good for beginners and not only for them);
  - for fans of the avy package: you can use avy to fold text with minimal
    number of key strokes!

    #+BEGIN_SRC emacs-lisp :name vimish-fold
      (use-package vimish-fold
        :commands vimish-fold-global-mode
        :defer 1
        :bind
        (:map vimish-fold-folded-keymap ("<tab>" . vimish-fold-unfold)
              :map vimish-fold-unfolded-keymap ("<tab>" . vimish-fold-refold))
        :init
        (setq-default vimish-fold-dir (expand-file-name ".vimish-fold/" flex-local-dir))
        (vimish-fold-global-mode 1)
        :config
        (setq-default vimish-fold-header-width 79))
    #+END_SRC

*** wgrep

[[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]] - Allows you to edit a grep buffer and apply those changes to the file buffer.

# TODO: Is this handled properly by =evil-collections?=

Usage:
You can edit the text in the *grep* buffer after typing `C-c C-p`.
After that the changed text is highlighted.
The following keybindings are defined:

- `C-c C-e`: Apply the changes to file buffers.
- `C-c C-u`: All changes are unmarked and ignored.
- `C-c C-d`: Mark as delete to current line (including newline).
- `C-c C-r`: Remove the changes in the region (these changes are not applied to the files. Of course, the remaining changes can still be applied to the files.)
- `C-c C-p`: Toggle read-only area.
- `C-c C-k`: Discard all changes and exit.
- `C-x C-q`: Exit wgrep mode.

To save all buffers that wgrep has changed, run

    M-x wgrep-save-all-buffers

To save buffer automatically when `wgrep-finish-edit'.

    (setq wgrep-auto-save-buffer t)

You can change the default key binding to switch to wgrep.

    (setq wgrep-enable-key "r")

To apply all changes wheather or not buffer is read-only.

    (setq wgrep-change-readonly-file t)

#+BEGIN_SRC emacs-lisp :name wgrep
(use-package wgrep
  :commands (wgrep-setup wgrep-change-to-wgrep-mode)
  :config (setq wgrep-auto-save-buffer t))
#+END_SRC

*** zzz-to-char

[[https://github.com/mrkkrp/zzz-to-char][zzz-to-char]] - Fancy replacement for zap-to-char in Emacs.  Allows you to
quickly select the exact char you want to zap to.

#+begin_src emacs-lisp :name zzz-to-char
(use-package zzz-to-char
  :init (setq zzz-to-char-reach 120))
#+end_src

* Evil

There are a couple of in spacemacs & doom-emacs

** Evil Mode settings

Basic settings and configuration for evil-mode.  Keybindings and mappings are
done in the =Keybindings= section at the end of this file.

#+BEGIN_SRC emacs-lisp :name evil-mode
(use-package evil
  :commands evil-mode
  :init
  (setq evil-default-state      'normal
        evil-want-C-u-scroll    t
        evil-want-C-w-delete    t
        evil-esc-delay          0
        evil-want-Y-yank-to-eol t
        evil-shift-width        4
        evil-want-integration   t
        evil-want-keybinding    nil  ; this is for evil-collection
        evil-want-C-i-jump      t)
  (setq-default evil-symbol-word-search 1)

  (evil-mode 1)
  :config

  ;; https://emacs.stackexchange.com/questions/14940/emacs-doesnt-paste-in-evils-visual-mode-with-every-os-clipboard/15054#15054
  ;; Imagine the following scenario.  One wants to paste some previously copied
  ;; (from application other than Emacs) text to the system's clipboard in place
  ;; of some contiguous block of text in a buffer.  Hence, one switches to
  ;; `evil-visual-state' and selects the corresponding block of text to be
  ;; replaced.  However, one either pastes some (previously killed) text from
  ;; `kill-ring' or (if `kill-ring' is empty) receives the error: "Kill ring is
  ;; empty"; see `evil-visual-paste' and `current-kill' respectively.  The
  ;; reason why `current-kill' does not return the desired text from the
  ;; system's clipboard is because `evil-visual-update-x-selection' is being run
  ;; by `evil-visual-pre-command' before `evil-visual-paste'.  That is
  ;; `x-select-text' is being run (by `evil-visual-update-x-selection') before
  ;; `evil-visual-paste'.  As a result, `x-select-text' copies the selected
  ;; block of text to the system's clipboard as long as
  ;; `x-select-enable-clipboard' is non-nil (and in this scenario we assume that
  ;; it is).  According to the documentation of `interprogram-paste-function',
  ;; it should not return the text from the system's clipboard if it was last
  ;; provided by Emacs (e.g. with `x-select-text').  Thus, one ends up with the
  ;; problem described above.  To solve it, simply make
  ;; `evil-visual-update-x-selection' do nothing:
  (fset 'evil-visual-update-x-selection 'ignore)

  ;; More Esc quits
  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key evil-insert-state-map [escape] 'evil-normal-state)
  (global-set-key [escape] 'evil-exit-emacs-state)
  )
#+END_SRC

** Evil Collection

[[https://github.com/emacs-evil/evil-collection][evil-collection]] - A community derived collection of evil-mode bindings for modes/parts of
Emacs that evil does not cover by default.

#+BEGIN_SRC emacs-lisp :name evil-collection
(use-package evil-collection
  :after evil
  :init
  (setq evil-collection-company-use-tng nil)
  :config
  (evil-collection-init))
#+END_SRC

** Evil Commentary

[[https://github.com/linktohack/evil-commentary][evil-commentary]] - A port of [[https://github.com/tpope/vim-commentary][vim-commentary]] by tpope

- =gcc= comments out a line (takes a count)
- =gc= comments out the target of a motion,
  e.g. =gcap= to comment out a paragraph (normal state)
  and =gc= to comment out the selection (visual state).

#+BEGIN_SRC emacs-lisp :name evil-commentary
  (use-package evil-commentary
    :config
    (evil-commentary-mode))
#+END_SRC

** Evil Magit

[[https://github.com/redguardtoo/evil-nerd-commenter][evil-magit]] - Help Evil & Magit play well together

#+BEGIN_SRC emacs-lisp :name evil-magit
(use-package evil-magit)
#+END_SRC

** Evil Numbers

http://github.com/cofi/evil-numbers
Increment/Decrement numbers in normal & visual modes.

#+BEGIN_SRC emacs-lisp :name evil-numbers
  (use-package evil-numbers
    :defer t
    :config
    (define-key evil-normal-state-map (kbd "C-c +") 'evil-numbers/inc-at-pt)
    (define-key evil-visual-state-map (kbd "C-c +") 'evil-numbers/inc-at-pt)

    (define-key evil-normal-state-map (kbd "C-c -") 'evil-numbers/dec-at-pt)
    (define-key evil-visual-state-map (kbd "C-c -") 'evil-numbers/dec-at-pt))
#+END_SRC

** Evil Surround

Package emulates surround.vim by Tpope.
https://github.com/emacs-evil/evil-surround

#+BEGIN_SRC emacs-lisp :name evil-surround
(use-package evil-surround
  :config
  (global-evil-surround-mode 1))
#+END_SRC

* Org mode

The manual: [[http://orgmode.org/manual/index.html][Org Manual]]

[[http://orgmode.org/manual/Easy-templates.html#Easy-templates][Easy templates:]]

<s <TAB> expands/completes the 'src' block
<e <TAB> -> example block
<q <TAB> -> quote
<v <TAB> -> verse; renders block quotes and newline breaks

Possibilities for adding unicode characters:
http://heikkil.github.io/blog/2015/03/22/hydra-for-unicode-input-in-emacs/
http://thewanderingcoder.com/2015/03/emacs-org-mode-styling-non-smart-quotes-zero-width-space-and-tex-input-method/

Markup:

http://ergoemacs.org/emacs/emacs_org_markup.

** library of functions for Org mode

ODO: Change the size or the screenshot before pasting it in.

+begin_src emacs-lisp :name deftmacs-org-functions
 ;; Modified from -> http://stackoverflow.com/a/31868530
 (defun defmacs::org-paste-screenshot ()
   "Paste the screenshot previously taken by the OS."
   (interactive)
   (org-display-inline-images)
   (setq filename
         (concat
          (make-temp-name
           (concat (file-name-nondirectory (buffer-file-name))
                   "_imgs/"
                   (format-time-string "%Y%m%d_%H%M%S_")) ) ".png"))
   (unless (file-exists-p (file-name-directory filename))
     (make-directory (file-name-directory filename)))
                                         ; take screenshot
   (if (eq system-type 'darwin)
       (call-process "pngpaste" nil nil nil filename))
                                         ;(call-process "screencapture" nil nil nil "-i" filename))
   (if (eq system-type 'gnu/linux)
       (call-process "import" nil nil nil filename))
                                         ; insert into file if correctly taken
   (if (file-exists-p filename)
       (insert (concat "[[file:" filename "]]"))))
+end_src

** Initial configuration

+begin_src emacs-lisp :name Org mode
   (use-package org-plus-contrib
     :defer t
     :mode (("\\.org$" . org-mode))
     :init
     (setq org-startup-indented t
           org-startup-folded "showall"
           org-ellipsis "⤵"              ;; Make the outline fold more compact.
           )

     ;; Modifications to Org mode Speed Keys - from Sacha Chau
     ;; To list all of the Speed Keys, go to the begining of a header and press ?
     (defun my/org-use-speed-commands-for-headings-and-lists ()
       "Activate speed commands on list items too."
       (or (and (looking-at org-outline-regexp) (looking-back "^\**"))
           (save-excursion (and (looking-at (org-item-re)) (looking-back "^[ \t]*")))))
     (setq org-use-speed-commands 'my/org-use-speed-commands-for-headings-and-lists)

     :config
     (org-load-modules-maybe t)
     ;; Some general configuration.
     (add-hook 'org-mode-hook (lambda ()
                                 (visual-line-mode 1)  ;; soft wrap
                                 (setq fill-column 120))))
   (eval-after-load 'org-mode
     (diminish 'org-indent-mode))



 ;; Tracking TODO state changes
 ;; The ! exclamation will add a timestamp
 ;; The @ ampersand will ask for a note with time-stamp
 (setq org-todo-keywords
       '((sequence "TODO(t!)" "WORKING(w!)" "DONE(d!)" "CANCELLED(c@!)" )))
+end_src

** Tags

isplay TAGS from column 72

+begin_src emacs-lisp :name org-tags
 (setq org-tags-column -72)
+end_src

** org-bullets

[https://github.com/sabof/org-bullets][org-bullets]] - UTF-8 bullets for org-mode bullets

+begin_src emacs-lisp :name org-bullets
use-package org-bullets
 :defer t
 :init
 (add-hook 'org-mode-hook (lambda ()
                            (org-bullets-mode 1))))
+end_src

** org-capture & org-protocol

[http://christiantietze.de/posts/2018/05/emacs-org-mode-global-capture-macos/][global-capture-macos]]

+BEGIN_SRC emacs-lisp :name org-capture

setq org-modules (quote (org-protocol)))

 (setq org-capture-templates
         (quote (("t" "todo" entry (file "~/tmp/Notes/general.org")
                  "* TODO %?\n%a\n"))))
+END_SRC

** org-download

[[https://github.com/abo-abo/org-download][org-download]] - Drag/drop/download images into Org

#+begin_src emacs-lisp :name org-download
  (use-package org-download)
#+end_src

* Version Control

** Magit

[[https://magit.vc/][Magit]] - The best git porcelain around.

#+BEGIN_SRC emacs-lisp :name magit
(setq vc-follow-symlinks t) ; follow symlinks

(use-package magit
  :commands (magit-status magit-blame)
  :config
  (setq  magit-log-arguments '("--graph" "--decorate" "--color")
         magit-save-repository-buffers 'dontask
         magit-revert-buffers 'silent)
  (set! :evil-state 'magit-status-mode 'emacs)
  (after! evil
    ;; Switch to emacs state only while in `magit-blame-mode', then back when
    ;; its done (since it's a minor-mode).
    (add-hook! 'magit-blame-mode-hook
      (evil-local-mode (if magit-blame-mode -1 +1)))))
#+END_SRC

** Magit Todos

https://github.com/alphapapa/magit-todos
Show TODOs in Magit status buffer for each file.


#+BEGIN_SRC emacs-lisp :name magit-todos
(use-package magit-todos
  :after magit
  :config
  (magit-todos-mode 1))
#+END_SRC

** git-gutter & git-gutter-fringe

[[https://github.com/syohex/emacs-git-gutter][git-gutter]] - Highlighting uncommited changes in the buffer.

#+BEGIN_SRC emacs-lisp :name git-gutter
(use-package git-gutter
  :commands global-git-gutter-mode
  :init
  (setq git-gutter:update-interval 0.1
        git-gutter:ask-p nil
        git-gutter:verbosity 0
        git-gutter:handled-backends '(git))

  (add-hook 'git-gutter:update-hooks 'magit-after-revert-hook)
  (add-hook 'git-gutter:update-hooks 'magit-not-reverted-hook)
  (add-hook 'git-gutter:update-hooks 'vc-checkin-hook)
  (add-hook 'git-gutter:update-hooks 'focus-in-hook)
  (add-hook 'git-gutter:update-hooks 'auto-revert-mode-hook)
  (add-hook 'git-gutter:update-hooks 'after-revert-hook)
  (global-git-gutter-mode 1))

(use-package git-gutter-fringe)
(require 'git-gutter-fringe)

;; Update git-gutter on focus (in case I was using git externally) - from hlissner's emacs config.
(add-hook 'focus-in-hook #'git-gutter:update-all-windows)

(set-face-foreground 'git-gutter-fr:modified "blue3")
(set-face-foreground 'git-gutter:modified "blue3")

;; Traverse git-gutter hunks using ivy mode.
;; http://blog.binchen.org/posts/enhance-emacs-git-gutter-with-ivy-mode.html
(require 'ivy)
(require 'git-gutter)

(defun my-reshape-git-gutter (gutter)
  "Re-shape gutter for `ivy-read'."
  (let* ((linenum-start (aref gutter 3))
         (linenum-end (aref gutter 4))
         (target-line "")
         (target-linenum 1)
         (tmp-line "")
         (max-line-length 0))
    (save-excursion
      ;; find out the longest stripped line in the gutter
      (while (<= linenum-start linenum-end)
        (goto-line linenum-start)
        (setq tmp-line (replace-regexp-in-string "^[ \t]*" ""
                                                 (buffer-substring (line-beginning-position)
                                                                   (line-end-position))))
        (when (> (length tmp-line) max-line-length)
          (setq target-linenum linenum-start)
          (setq target-line tmp-line)
          (setq max-line-length (length tmp-line)))

        (setq linenum-start (1+ linenum-start))))
    ;; build (key . linenum-start)
    (cons (format "%s %d: %s"
                  (if (eq 'deleted (aref gutter 1)) "-" "+")
                  target-linenum target-line)
          target-linenum)))

(defun my-goto-git-gutter ()
  (interactive)
  (if git-gutter:diffinfos
      (let* ((collection (mapcar 'my-reshape-git-gutter
                                 git-gutter:diffinfos)))
        (ivy-read "git-gutters:"
                  collection
                  :action (lambda (linenum)
                            (goto-line linenum))))
    (message "NO git-gutters!")))
#+END_SRC

** git-messenger

[[https://github.com/syohex/emacs-git-messenger][git-messenger]] - Provides a function that pops up the commit message of the current line.

#+BEGIN_SRC emacs-lisp :name git-messenger
(use-package git-messenger
  :init
  (setq git-messenger:show-detail t
         git-messenger:handled-backends '(git))
  :config
  (define-key git-messenger-map (kbd "m") 'git-messenger:copy-message))
#+END_SRC

** git-timemachine

[[https://github.com/pidu/git-timemachine][git-timemachine]] - Allows you to go back and forth to the revisions of a file.

#+BEGIN_SRC emacs-lisp :name git-timemachine
(use-package git-timemachine
  :commands (git-timemachine git-timemachine-toggle)
  :config
  (require 'magit-blame)
  ;; Sometimes I forget `git-timemachine' is enabled in a buffer, so instead of
  ;; showing revision details in the minibuffer, show them in
  ;; `header-line-format', which has better visibility.
  (setq git-timemachine-show-minibuffer-details nil)
  (add-hook 'git-timemachine-mode-hook #'+vcs|init-header-line)
  (advice-add #'git-timemachine-show-revision :after #'+vcs*update-header-line)

  ;; Force evil to rehash keybindings for the current state
  (add-hook 'git-timemachine-mode-hook #'evil-force-normal-state))

;; From redguardtoo - http://blog.binchen.org/posts/new-git-timemachine-ui-based-on-ivy-mode.html
(defun my-git-timemachine-show-selected-revision ()
  "Show last (current) revision of file."
  (interactive)
  (let (collection)
    (setq collection
          (mapcar (lambda (rev)
                    ;; re-shape list for the ivy-read
                    (cons (concat (substring (nth 0 rev) 0 7) "|" (nth 5 rev) "|" (nth 6 rev)) rev))
                  (git-timemachine--revisions)))
    (ivy-read "commits:"
              collection
              :action (lambda (rev)
                        (git-timemachine-show-revision rev)))))

(defun my-git-timemachine ()
  "Open git snapshot with the selected version.  Based on ivy-mode."
  (interactive)
  (unless (featurep 'git-timemachine)
    (require 'git-timemachine))
  (git-timemachine--start #'my-git-timemachine-show-selected-revision))
#+END_SRC

** gitignore-mode

[[https://github.com/magit/git-modes][gitignore-mode]] - Pull in the mode for editing .gitignore files.

#+BEGIN_SRC emacs-lisp :name gitignore-mode
(use-package gitignore-mode
  :defer t)
#+END_SRC

** git-link

[[https://github.com/sshaw/git-link][git-link]] - Create URLs for files and commits in GitHub/Bitbucket/GitLab/... repositories.

#+BEGIN_SRC emacs-lisp :name git-link
(use-package git-link
  :commands (git-link git-link-commit git-link-homepage))
#+END_SRC

* Software Development
** Software Development Utilities
*** dumb-jump

[[https://github.com/jacktasia/dumb-jump][dumb-jump]] - A "jump to definition" package for Emacs.  Works without index files, TAGS, etc.

#+BEGIN_SRC emacs-lisp :name dumb-jump
    (use-package dumb-jump
      :init
      (setq dumb-jump-force-searcher 'rg
            dumb-jump-selector 'ivy)
      :config
      (setq dumb-jump-aggressive nil))
#+END_SRC

*** flycheck

[[http://www.flycheck.org/en/latest/][flycheck]] - on the fly syntax checking

#+begin_src emacs-lisp :name flycheck
  (use-package flycheck
    :commands global-flycheck-mode
    :defer t
    :init
    (setq flycheck-standard-error-navigation      nil
          flycheck-idle-change-delay              15
          flycheck-disabled-checkers              '(tex-chktex emacs-lisp-checkdoc)
          flycheck-emacs-lisp-initialize-packages t
          flycheck-check-syntax-automatically     '(mode-enabled idle-change save))

    ;; Turn off for some modes
    ;; Turns off for *scratch* buffer.
    (setq flycheck-global-modes '(not lisp-interaction-mode org-mode))

    ;; Turn on everywhere else.
    (add-hook 'after-init-hook #'global-flycheck-mode)
    :config

    ;; (push '("^\\*Flycheck.+\\*$" :regexp t :dedicated t :position bottom :stick t :noselect t) popwin:special-display-config)
    )

  ;; so that linting and type errors don't mess with eldoc
  (use-package flycheck-pos-tip
    :defer t
    :diminish flycheck-pos-tip-mode
    :config (flycheck-pos-tip-mode))

  (use-package helm-flycheck
    :defer t)
#+end_src

*** yasnippet

I use [[https://github.com/joaotavora/yasnippet][yasnippet]] for all of my snippet needs - the [[http://joaotavora.github.io/yasnippet/][manual]].

#+begin_src emacs-lisp :name yasnippet
  (use-package yasnippet-snippets)

  (use-package yasnippet
    :commands yas-global-mode
    :mode ("/\\.emacs\\.d/snippets/" . snippet-mode)
    :init
    (setq yas-snippet-dirs '("~/.emacs.d/snippets")
          yas-verbosity 3)
    (yas-global-mode 1)
    (use-package helm-c-yasnippet))
#+end_src

**** auto-yasnippet

[[https://github.com/abo-abo/auto-yasnippet][auto-yasnippet]] - quickly create disposable snippets.

A basic example:
Suppose we want to write:

```js
count_of_red = get_total("red");
count_of_blue = get_total("blue");
count_of_green = get_total("green");
```

We write a template, using ~ to represent variables that we want to
replace:

```
count_of_~red = get_total("~red");
```

Call `aya-create` with point on this line, and the template is
converted to a value we want:

```
count_of_red = get_total("red");
```

Then call `aya-expand` and you can 'paste' additional instances of
the template. Yasnippet is active, so you can tab between
placeholders as usual.

```
count_of_red = get_total("red");
count_of_ = get_total("");
```
#+BEGIN_SRC emacs-lisp :name auto-yasnippet
  (use-package auto-yasnippet
    :commands (aya-create aya-expand aya-open-line))
#+END_SRC

** Programming Languages
*** Common Lisp

#+begin_src emacs-lisp :name common-lisp
  (use-package slime
    :commands slime-setup
    :init (setq inferior-lisp-program "/usr/local/bin/sbcl")
    :config
    (use-package slime-company
      :after slime
      :ensure slime-company
      :config
      (slime-setup '(slime-fancy slime-company))))
#+end_src

*** Emacs Lisp
**** Settings

#+begin_src emacs-lisp :name emacs-lisp-settings
  ;; (add-hook 'emacs-lisp-mode-hook #'aggressive-mode-hook)
#+end_src

**** cl-lib highlighting

[[https://github.com/skeeto/cl-lib-highlight][cl-lib-highlight]] - Syntax highlighting for cl-lib, so that =cl-loop=, =cl-defun=, =cl-defstruct= and the like get highlighted

#+begin_src emacs-lisp :name cl-lib highlighting
  (use-package cl-lib-highlight
    :config
    (cl-lib-highlight-initialize))
#+end_src

**** Evaluation

Borrowed from Sacha Chau who borrowed it from Steve Purcell - change
=C-x C-e= to evaluate regions as well as last sexp.

#+begin_src emacs-lisp :name emacs-lisp-evaluation
  (defun sanityinc/eval-last-sexp-or-region (prefix)
    "Eval region from BEG to END if active, otherwise the last sexp."
    (interactive "P")
    (if (and (mark) (use-region-p))
        (eval-region (min (point) (mark)) (max (point) (mark)))
      (pp-eval-last-sexp prefix)))

  (bind-key "C-x C-e" 'sanityinc/eval-last-sexp-or-region emacs-lisp-mode-map)
#+end_src

**** elisp-slime-nav

[[https://github.com/purcell/elisp-slime-nav][elisp-slime-nav]] - Slime-style navigation of Emacs Lisp source.

#+begin_src emacs-lisp :name elisp-slime-nav
;; elisp-slime-nav-find-elisp-thing-at-point
;; elisp-slime-nav-describe-thing-at-point
(use-package elisp-slime-nav
  :defer t
  :diminish elisp-slime-nav-mode
  :config
  (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook lisp-interaction-mode-hook))
    (add-hook hook 'elisp-slime-nav-mode)))
#+end_src

**** eldoc

#+begin_src emacs-lisp :name eldoc
(use-package "eldoc"
  :diminish eldoc-mode
  :commands turn-on-eldoc-mode
  :init
  (progn
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)))
#+end_src

**** ielm

REPL for elisp

#+begin_src emacs-lisp :name ielm
  (setq ielm-noisy nil)

  ;; Attribution - https://masteringemacs.org/article/evaluating-elisp-emacs
  ;; (defun ielm-auto-complete ()
  ;;   "Enables `auto-complete' support in \\[ielm]."
  ;;   (setq ac-sources '(ac-source-functions
  ;;                      ac-source-variables
  ;;                      ac-source-features
  ;;                      ac-source-symbols
  ;;                      ac-source-words-in-same-mode-buffers))
  ;;   (add-to-list 'ac-modes 'inferior-emacs-lisp-mode)
  ;;   (auto-complete-mode 1))
  ;; (add-hook 'ielm-mode-hook 'ielm-auto-complete)

  (use-package ielm
    :config (add-hook 'ielm-mode-hook '(lambda ()
                                         (smartparens-mode 1)
                                         (eldoc-mode 1))))
#+end_src

*** Golang

Support for golang.

Be sure to install the tools support for Go first:

go get -u github.com/nsf/gocode
go get -u github.com/rogpeppe/godef
go get -u golang.org/x/tools/cmd/goimports
go get -u github.com/jstemmer/gotags
go get github.com/matryer/moq

#+BEGIN_SRC emacs-lisp :name go-mode
(use-package go-mode
  :config
  (add-hook 'before-save-hook #'gofmt-before-save)
  (add-hook 'go-mode-hook 'flycheck-mode)
  (add-hook 'go-mode-hook 'dumb-jump-mode)
  (setq go-packages-function 'go-packages-go-list))
#+END_SRC

**** Enable =company-go=
#+BEGIN_SRC emacs-lisp
  (use-package company-go
    :config
    (add-hook 'go-mode-hook 'company-mode)
    (add-to-list 'company-backends 'company-go))
#+END_SRC

**** Enable =go-stackstracer=
#+BEGIN_SRC emacs-lisp
  (use-package go-stacktracer)
#+END_SRC

**** Enable =go-add-tags=
#+BEGIN_SRC emacs-lisp
  (use-package go-add-tags)
#+END_SRC

**** Enable =go-eldoc=
#+BEGIN_SRC emacs-lisp
  (use-package go-eldoc
    :diminish eldoc-mode
    :config (add-hook 'go-mode-hook 'go-eldoc-setup))
#+END_SRC

**** Enable =go-gopath=
#+BEGIN_SRC emacs-lisp
  (use-package go-gopath)
#+END_SRC

**** Enable =go-direx=
#+BEGIN_SRC emacs-lisp
  (use-package go-direx)
#+END_SRC

**** Enable =gotest=
#+BEGIN_SRC emacs-lisp
  (use-package gotest)
#+END_SRC

**** Integrate =moq=
Quick custom function to integrate with the moq tool to generate quick mocks
#+BEGIN_SRC emacs-lisp
  (defun moq ()
    (interactive)
    (let ((interface (word-at-point))
          (test-file (concat (downcase (word-at-point)) "_test.go")))
      (shell-command
       (concat "moq -out " test-file " . " interface))
      (find-file test-file)))
#+END_SRC

**** See test coverage faster

Simple function to see the test coverage of the current open buffer

#+BEGIN_SRC emacs-lisp
    (defun go-coverage-here ()
      (interactive)
      (shell-command "go test . -coverprofile=cover.out")
      (go-coverage "cover.out")
      (rotate:even-horizontal))
#+END_SRC

*** Javascript

Because work.

#+begin_src emacs-lisp :name js2-mode
(use-package js2-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode)))
#+end_src

*** Python

**** Initial Configuration

#+begin_src emacs-lisp :name python
  (require 'smartparens-python)

  (defun deftmacs:python-mode ()
    (interactive)
    ;; (add-to-list (make-local-variable 'company-backends 'company-jedi))
    ;; I prefer superword-mode for python
    (superword-mode)
    (diminish 'superword-mode)

    ;; Jedi for autocomplete
    ;; Thu Aug 10 09:25:28 2017 - commented jedi:setup out and now
    ;; Python autocomplete works as expected
    ;; (jedi:setup)
    (setq jedi:complete-on-dot t)
    (setq jedi:get-in-function-call-delay 500)
    (setq jedi:tooltip-method '(popup))

    ;; Turn off flyspell-mode - it interferes with jedi popup timing.
    ;; NOTE: Also make sure NOT to enable flyspell-prog-mode as this will interfere as well.
    (flyspell-mode 0)
    (flyspell-prog-mode 0)

    ;; flycheck
    (flycheck-mode 1)
    (setq flycheck-flake8rc "~/.flake8"
          flycheck-flake8-maximum-line-length 105
          flycheck-checker 'python-flake8)
    )

    (add-hook 'python-mode-hook 'deftmacs:python-mode)
#+end_src

**** pyvenv

Using [[https://github.com/jorgenschaefer/pyvenv][pyvenv]] to manage conda environments.

#+begin_src emacs-lisp :name pyenv
  (use-package pyvenv
    :ensure t
    :config
    (setenv "WORKON_HOME" "~/miniconda3/envs")
    (pyvenv-mode 1)
    (pyvenv-tracking-mode 1))
#+end_src

*** Shell

#+begin_src emacs-lisp :name shell scripting
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+end_src

* Miscellaneous file type support
*** csv

Comma (or other delimiter) separated files.

#+begin_src emacs-lisp :name csv
(use-package csv-nav
  :load-path "emacswikilibs/csv-nav/"
  :defer t
  :mode ("\\.[Cc][Ss][Vv]\\'" . csv-mode)
  :init
  (progn
    (use-package csv-mode)
    (setq csv-separators '("," ";" "|" " "))))
#+end_src

*** Docker file mode

[[https://github.com/spotify/dockerfile-mode][dockerfile-mode]] for editing Docker files

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :config (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))
#+END_SRC

*** jinja2

[[https://github.com/paradoxxxzero/jinja2-mode][jinja2-mode]] - A major mode for jinja2 templates.

#+begin_src emacs-lisp :name jinja2-mode
  (use-package jinja2-mode
    :ensure t)
#+end_src

*** Salt mode

[[https://github.com/glynnforrest/salt-mode][salt-mode]] - Mode for editing Salt states

#+begin_src emacs-lisp :name salt-mode
  (use-package salt-mode)
#+end_src

*** SQL Mode

The interactive SQL mode is based on ComintMode. The following interpreters are supported:

    psql by PostgreSQL
    mysql by MySQL
    sqlite or sqlite3 for SQLite

    #+begin_src emacs-lisp :name sql-mode
      (add-to-list 'same-window-buffer-names "*SQL*")

      (add-hook 'sql-interactive-mode-hook
                (lambda ()
                  (toggle-truncate-lines t)))
    #+end_src

*** Yaml & Json

Json mode

#+begin_src emacs-lisp :name json-mode
  (use-package json-mode
    :defer t
    :diminish json-mode)
#+end_src

YAML mode

#+begin_src emacs-lisp :name yaml-mode
  (use-package yaml-mode
    :mode ("\\.yml$" "\\.sls$")
    :diminish yaml-mode
    :config
    (with-eval-after-load 'yaml-mode
      '(define-key yaml-mode-map (kbd "C-j""") nil))
    (add-hook 'yaml-mode-hook
              (lambda ()
                (setq-local eclectric-indent-mode nil))))
#+end_src

* Prose
** flyspell

Check spelling on the fly.  Uses ispell under the hood.

#+BEGIN_SRC emacs-lisp :name flyspell
(use-package flyspell
  :defer 1
  :custom
  (flyspell-abbrev-p t) ; Correct spelling errors & add them to abbrev_defs at the same time.
  (flyspell-issue-message-flag nil)
  (flyspell-issue-welcome-flag nil)
  (flyspell-mode 1))

(use-package flyspell-correct-ivy
  :after flyspell
  :bind (:map flyspell-mode-map
        ("C-;" . flyspell-correct-word-generic))
  :custom (flyspell-correct-interface 'flyspell-correct-ivy))
#+END_SRC

** lorem-ipsum

[[https://github.com/jschaf/emacs-lorem-ipsum][Lorem Ipsum]] add filler text to whatever you are working on.  The following
commands are available:
=lorem-ipsum-insert-sentences=
=lorem-ipsum-insert-paragraphs=
=lorem-ipsum-insert-list=

#+begin_src emacs-lisp :name lorem ipsum
  (use-package lorem-ipsum
    :defer t)
#+end_src

** Markdown mode

[[http://jblevins.org/projects/markdown-mode/][Markdown Mode]] - Major mode for editing [[http://daringfireball.net/projects/markdown/][Markdown]] formatted text.

#+begin_src emacs-lisp :name markdown
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'"       . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown")
  :config
  (defun flex-emacs:mardown ()
    (interactive)
    (smartparens-mode -1))
  (add-hook 'markdown-mode #'flex-emacs:mardown))
#+end_src

[[http://joostkremers.github.io/pandoc-mode/][Pandoc]] - Convert text written in one markup language into another markup language.

It is possible to create different output profiles for a single input file, so that you
can, for example, write your text in Markdown and then translate it to HTML for online
reading, PDF for offline reading and Texinfo for reading in Emacs

#+begin_src emacs-lisp :name Pandoc
  (use-package pandoc-mode)
#+end_src

[[https://github.com/blak3mill3r/vmd-mode][vmd-mode]] - Fast Github-flavored Markdown previews synchronized with changes to an
           emacs buffer (no need to save).
Dependencies: Node.js & vmd

[[https://github.com/yoshuawuyts/vmd][vmd]] - can be installed with ```npm install -g vmd```

#+begin_src emacs-lisp :name vmd-mode
  (use-package vmd-mode)
#+end_src

** Text mode

#+begin_src emacs-lisp :name text mode
  (add-hook 'text-mode-hook '(lambda ()
                               (auto-fill-mode 1)
                               (setq word-wrap 1)))
#+end_src

* Keybindings
** Configuration & Settings
*** General

[[https://github.com/noctuid/general.el][general.el]] - Use general.el to setup evil-mode, leader and other keybindings.

Set the 'general-override-states' and enable the 'general-override-mode' so
that evil-collection and others don't override bindings that I want.

#+BEGIN_SRC emacs-lisp :name general.el
(use-package general
  :commands (general-create-definer general-define-key general-override-mode)
  :config
  (setq general-override-states '(insert
                                  emacs
                                  hybrid
                                  normal
                                  visual
                                  motion
                                  operator
                                  replace))
  (general-override-mode))
#+END_SRC

*** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] - Make Emacs bindings that stick around.

The :color key is a shortcut. It aggregates :exit and :foreign-keys key in the following way:

| color    | toggle                     |
|----------+----------------------------|
| red      |                            |
| blue     | :exit t                    |
| amaranth | :foreign-keys warn         |
| teal     | :foreign-keys warn :exit t |
| pink     | :foreign-keys run          |

It's also a trick to make you instantly aware of the current hydra keys that you're about to press: the
keys will be highlighted with the appropriate color.

#+begin_src emacs-lisp :name Hydra
(use-package hydra)
#+end_src

*** key-chord

[[https://www.emacswiki.org/emacs/key-chord.el][key-chord]] - Map pairs of simultaneously pressed keys to commands.

Keychord has a couple of drawbacks
1. Doesn't get recorded when recording macros.
2. Can't use function keys in keychords
3. Doesn't work well with internationalization packages.

#+begin_src emacs-lisp :name key-chord
  (use-package key-chord
    :commands key-chord-mode
    :init
    (key-chord-mode 1))
#+end_src

*** which-key

[[https://github.com/justbur/emacs-which-key][which-key]] - Display available keybindings.

   - =which-key-show-top-level= will show most key bindings without a prefix. It
     is most and not all, because many are probably not interesting to most
     users.
   - =which-key-show-major-mode= will show the currently active major-mode
     bindings. It's similar to =C-h m= but in a which-key format. It is also
     aware of evil commands defined using =evil-define-key=.
   - =which-key-show-next-page= is the command used for paging.
   - =which-key-undo= can be used to undo the last keypress when in the middle
     of a key sequence.

#+BEGIN_SRC emacs-lisp :name which-key
    (use-package which-key
      :after evil
      :commands which-key-mode
      :init
      (setq which-key-allow-evil-operators t
            which-key-show-operator-state-maps t))
#+END_SRC

** Ctrl/Alt/Super

#+begin_src emacs-lisp :name keybindings
  ;; a
  (global-unset-key (kbd "s-a"))
  ;; d
  (global-unset-key (kbd "s-d"))
  (global-unset-key (kbd "C-s-d"))
  (global-set-key (kbd "s-C-d") 'crux-insert-date)
  ;; f
  (global-unset-key (kbd "s-f"))
  (global-set-key (kbd "s-f") 'avy-goto-char-in-line)
  ;; g
  (global-unset-key (kbd "s-g"))
  ;; h
  (global-unset-key (kbd "s-h"))
  ;; j
  (global-unset-key (kbd "s-j"))
  ;; k
  (global-unset-key (kbd "s-k"))
  ;; l
  (global-unset-key (kbd "s-l"))
  ;; n
  (global-unset-key (kbd "s-n"))
  ;; p
  (global-unset-key (kbd "s-p"))
  ;; r
  (global-unset-key (kbd "s-r"))
  (global-set-key (kbd "s-r") 'recenter-positions)
  ;; t
  (global-unset-key (kbd "s-S-t"))
  (global-unset-key (kbd "s-t"))
  ;; z
  (global-unset-key (kbd "s-z"))
  ;; -
  (global-unset-key (kbd "s--"))
  ;; arrows
  (global-set-key (kbd "M-<left>") 'backward-word)
  (global-set-key (kbd "M-<right>") 'forward-word)

  ;; Rebind =C-x C-e= so that it evaulutates regions as well.
  (bind-key "C-x C-e" 'sanityinc/eval-last-sexp-or-region emacs-lisp-mode-map)

#+end_src

** Escape

Some code to use =Escape= to quit more things. Between Evil and this we should
have most instances covered.

You would think that [[https://github.com/syl20bnr/evil-escape][evil-escape]] would be a possibility but it uses =fd= as a keychord
to <escape>.  Not really what I was wanting to do.

#+begin_src emacs-lisp :name Escape keys
 (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
 (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
 (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
 (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
 (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)

 (defun my-helm-init ()
   (interactive)
   (define-key helm-map (kbd "ESC") 'helm-keyboard-quit))
 (add-hook 'after-init-hook 'my-helm-init)

 ;; Map Escape to cancel like C-g
 (define-key isearch-mode-map [escape] 'isearch-abort)   ;; isearch
 (define-key isearch-mode-map "\e" 'isearch-abort)       ;; \e seems to work better for terminals
 ;; TODO Thu Jun 30 16:41:14 2016 - This causes splits to close for some reason???
 ;;  (global-set-key [escape] 'keyboard-escape-quit)         ;; everywhere else
#+end_src

** Hydra maps
*** hydra-cee

Hydra for what would normally be ~C-c x~ or ~C-c C-x~ commands.

#+begin_src emacs-lisp :name hydra-cee
  (defhydra hydra-cee (:color blue :hint nil)
    "
                                                                                    ,--------------------.
                                                                                    | Ctrl-c or the like |
      ,-----------------------------------------------------------------------------'--------------------'

                                     [_i_] Semantic or Imenu                          [_v_] Pyvenv Environment
                                     [_k_] Show kill ring
                                     [_l_] Flycheck            [_s_] Helm Snippets    [_y_] New Snippet
                                     [_m_] Multiterm           [_t_] Todo/Note/Bug

  "
    ("d" crux-insert-date)
    ("i" helm-semantic-or-imenu)
    ("k" helm-show-kill-ring)
    ("l" hydra-flycheck/body :exit t)
    ("m" helm-mt)
    ("s" helm-yas-complete)
    ("t" deftpunk/hltodo-swiper)
    ("v" pyvenv-workon)
    ("y" yas-new-snippet)
    ("<ESC>" nil "Quit" :exit t)
    )
#+end_src

*** hydra-files-projectile

#+begin_src emacs-lisp :name hydra-files-projectile
  (defhydra hydra-files-projectile (:color blue
                                    :hint nil)
  "
    ,----------------------.
   | Files, Projects, etc. |   CURRENT PROJECT: %(if (fboundp 'projectile-project-root) (projectile-project-root) \"NO Project\")
   '-----------------------'--------------------------------------------------------------------------.




  _a_ Ag                                             _m_ Go to *Messages*     _s_ Go to *scratch*

  _c_ Clear Projectile Cache
                                                     _p_ Switch Projects
                                _k_ Kill Buffer
  _f_ Find File

  "
  ("a" (lambda ()
         (interactive)
         (if (no-projectile-projectp)
             (helm-do-ag)
           (helm-projectile-ag))))
  ("c" projectile-invalidate-cache)
  ("f" counsel-find-file)
  ("k" kill-buffer) ; gets you a Helm interface to choose which buffer.
  ("m" (lambda ()
         (interactive)
         (let ((messages-buffer (get-buffer-create "*Messages*")))
           (switch-to-buffer messages-buffer))))
  ("n" make-frame)
  ("p" projectile-switch-project)
  ("s" eme-goto-scratch)

  ("<ESC" nil "Quit" :exit t))
#+end_src

*** hydra-flycheck

A hydra to open up flycheck errors and navigation through them - [[https://github.com/abo-abo/hydra/wiki/Flycheck][Source]]

Made the following changes:
 Added the change to disable flycheck-pos-tip-mode and renable it; it slowed
 down the movement between errors.
 Added the option t to quit-windows-on; this closes the created window.

#+begin_src emacs-lisp :name hydra-flycheck
  (defhydra hydra-flycheck
    (:pre (progn (setq hydra-lv t) (flycheck-list-errors) (flycheck-pos-tip-mode -1))
          :post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*" t) (flycheck-pos-tip-mode 1))
          :hint nil)
    "
                                                                            ,-----------------.
                                                                            | Flycheck Errors |
    ,-----------------------------------------------------------------------'-----------------'
      [_f_] Filter
      [_j_] Next Error
      [_k_] Previous Error
      [_gg_] First Error
      [_G_] Last Error
    "
    ("f"  flycheck-error-list-set-filter)
    ("j"  flycheck-next-error)
    ("k"  flycheck-previous-error)
    ("gg" flycheck-first-error)
    ("G"  (progn (goto-char (point-max)) (flycheck-previous-error)))
    ("q" nil "Quit")
    ("<ESC>" nil "Quit"))
#+end_src

*** hydra +version-control@git-gutter

Move around the various git-gutter hunks.

#+begin_src emacs-lisp :name +version-control@git-gutter
(defhydra +version-control@git-gutter
    (:body-pre (git-gutter-mode 1) :hint nil)
    "
                                     ╭─────────────────┐
  Movement   Hunk Actions     Misc.  │ gg: +%-4s(car (git-gutter:statistic))/ -%-3s(cdr (git-gutter:statistic)) │
  ╭──────────────────────────────────┴─────────────────╯
     ^_g_^       [_s_] stage        [_R_] set start Rev
     ^_k_^       [_r_] revert
     ^↑ ^      [_m_] mark
     ^↓ ^      [_p_] popup          ╭──────────────────────
     ^_j_^                          │[_q_] quit
     ^_G_^                          │[_Q_] Quit and disable"
    ("j" (progn (git-gutter:next-hunk 1) (recenter)))
    ("k" (progn (git-gutter:previous-hunk 1) (recenter)))
    ("g" (progn (goto-char (point-min)) (git-gutter:next-hunk 1)))
    ("G" (progn (goto-char (point-min)) (git-gutter:previous-hunk 1)))
    ("s" git-gutter:stage-hunk)
    ("r" git-gutter:revert-hunk)
    ("m" git-gutter:mark-hunk)
    ("p" git-gutter:popup-hunk)
    ("R" git-gutter:set-start-revision)
    ("q" nil :color blue)
("Q" (git-gutter-mode -1) :color blue))
#+end_src

*** hydra-version-control

Hydra for version control functions.

#+begin_src emacs-lisp :name hydra-version-control
 (defhydra hydra-version-control (:color blue :hint nil)
   "
 git-messenger
 -------------
 c - Copy commit ID        s - Pop up git show --stat
 d - Pop up git diff       S - Pop up git show --stat -p
 m - Copy commit message   q - Quit


                                                                     ,-------------------.
     General                    Git                                  | Version control   |
   ,-----------------------------------------------------------------'-------------------'
   [_v_] Magit status          [_m_] git-messenger
   [_a_] vc-annotate           [_s_] stage file
                               [_u_] unstage file
                               [_b_] blame
                               [_t_] timemachine

 "
   ("a" vc-annotate)

   ;; If currently monky-blame-mode then quit it, else try to blame current
   ;; file.  If no, check magit-blame-mode and either quit that or start
   ;; magit-blame.
  ("b" (lambda ()
         (interactive)
         (if (bound-and-true-p magit-blame-mode)
             (magit-blame-quit)
           (call-interactively 'magit-blame))))
   ("g" +version-control@git-gutter/body)
   ("m" git-messenger:popup-message)
   ("s" magit-stage-file)
   ("t" git-timemachine)
   ("u" magit-unstage-file)
   ("v" magit-status)

   ("<ESC>" nil "quit")
   )
#+end_src

*** hydra-window-sizing

Resize windows dynamically

#+begin_src emacs-lisp :name hydra-window-sizing
   (defhydra hydra-window-sizing (:color blue)
     "
 .------------------,
 | Window Re-sizing |
 '------------------'--------------------------------------------------------------------.

                        ^Enlarge Vertically^

		     ^[_k_]^
		      ^^↑^^

  Shrink Horizontally [_h_] ←    → [_l_] Enlarge Horizontally

                             ^^↓^^
                            ^[_j_]^

		Shrink Vertically
   "
     ("<tab>" hydra-windows/back "Back to windows")

     ("h" (lambda ()
            (interactive)
            (shrink-window-horizontally 5)) :color pink)
     ("j" (lambda ()
            (interactive)
            (shrink-window 5)) :color pink)
     ("k" (lambda ()
            (interactive)
            (enlarge-window 5)) :color pink)
     ("l" (lambda ()
            (interactive)
            (enlarge-window-horizontally 5)) :color pink)

     ("<ESC>" nil "Quit"))
#+end_src

** Hydra mode maps
*** hydra-emacs-lisp

 hydra for Elisp modes.  It inherits the smartparens hydra.

#+begin_src emacs-lisp :name hydra-emacs-lisp
 (defhydra hydra-emacs-lisp (:color red)
   "
                                                            ,-----------------.
    Docs               Utilities                            | Emacs Lisp Mode |
------------------------------------------------------------'-----------------'
 [_d_] Describe        [_i_] ELM
                       [_p_] ELP
"
   ("d" describe-foo-at-point :exit t)
   ("e" eval-expression :exit t)
   ("i" ielm :exit t)
   ("p" hydra-emacs-lisp-profiler/body :exit t)
   ("r" eval-region :exit t)
   ("x" eval-defun :exit t)
   ("<ESC>" nil "Quit" :exit t)
   )
#+end_src

*** hydra-org-mode

 hydra for Org mode

#+begin_src emacs-lisp :name hydra-orgmode
 (defhydra hydra-orgmode-mode (:color blue
                               :hint nil)
   "
                                                                         .-----------.
                                                                         |  Org Mode |
   ,---------------------------------------------------------------------'-----------'
   [_e_] Mark element
   [_h_] Helm buffer headings
   [_s_] Mark subtree
   [_o_] Ace link
 "
   ("e" org-mark-element)
   ("h" helm-org-in-buffer-headings)
   ("s" org-mark-subtree)
   ("o" ace-link-org)
   ("<ESC>" nil "Quit" :exit t))
#+end_src

*** hydra-python-mode

 hydra for python.

#+begin_src emacs-lisp :name hydra-python
 (defhydra hydra-python-mode (:color blue
                                     :hint nil)
   "
                                                                           .----------.
                                                                           |  Python  |
     ,---------------------------------------------------------------------'----------'
     [_d_] Jedi - goto definition
     [_m_] Python Mark function
     [_p_] Jedi - Pop goto definition
     [_w_] Pyvenv workon Env
   "
   ("d" jedi:goto-definition)
   ("m" python-mark-defun)
   ("p" jedi:goto-definition-pop-marker)
   ("w" pyvenv-workon)
   ("<ESC>" nil "Quit" :exit t))
#+end_src

** hydra-jk

 Hydra for the jk keychord - see Keychord below for more information.

#+begin_src emacs-lisp :name hydra-jk
 (defun deftpunk/hydra-major-mode-hack ()
   "Mucho hackiness to get different hydras for different modes but the same
 prefix key.  There has to be a better way."
   (interactive)
   (let ((my-hmodes '((lisp-interaction-mode . hydra-emacs-lisp/body)
                      (python-mode . hydra-python-mode/body)
                      (org-mode . hydra-orgmode-mode/body)
                      (emacs-lisp-mode . hydra-emacs-lisp/body))))
     (condition-case error
         (funcall (assoc-default major-mode my-hmodes))
       ('error (message "No Hydra for this major mode: %s" major-mode)))))

 (defhydra hydra-jk (:color blue :hint nil)
  "
,----------------.
| Master Blaster |
'----------------'---------------------------------------------------------------------------------

    [_x_] Helm/Counsel M-x        [_q_] Exit Emacs
  "
  ("q" save-buffers-kill-terminal)
  ("x" helm-M-x)

  ("<ESC>" nil "Quit" :exit t)
  )
#+end_src

** Evil States, Evil maps, Leader and Local Leader mappings

Keymapping with Evil adds a little more complexity - see the [[https://github.com/syl20bnr/spacemacs/wiki/Keymaps-guide][Spacemacs Keymap Guide]] and
starting with the [[https://github.com/noctuid/evil-guide#keymap-precedence][Keymap Precedence section]] of noctuid's [[https://github.com/noctuid/evil-guide][Evil Guide]] .

#+BEGIN_SRC emacs-lisp :name evil-mappings

     ;;;
     ;;; Evil maps - not state maps
     ;;;

  (general-define-key
   :states 'normal
   :keymaps 'help-mode-map
   "o" 'ace-link-help        ; was getting overwritten by evil-collection-help.el
   "SPC" 'nil                ; don't want anything messing with our leader key
   )

  ;; Add some bindings to the window "C-w <something" map.
  ;; Thu Nov 22 22:54:18 2018 - we have to bind evil-window-map this way, as
  ;; opposed to using general.el
  (define-key evil-window-map "b" 'balance-windows)          ; replaces evil-window-bottom-right.
  (define-key evil-window-map "d" 'ace-delete-window)        ; was unused
  (define-key evil-window-map "e" 'hydra-window-sizing/body) ; was unused
  (define-key evil-window-map "f" 'make-frame)               ; was unused
  (define-key evil-window-map "i" 'ace-maximize-window)      ; was unused
  (define-key evil-window-map "m" 'doom/toggle-fullscreen)   ; was unused
  (define-key evil-window-map "r" 'winner-redo)              ; replaces evil-window-rotate-downwards
  (define-key evil-window-map "u" 'winner-undo)              ; was unused
  (define-key evil-window-map "-" 'ace-window)               ; was unused
  (define-key evil-window-map "\\" '(lambda ()
                                      (interactive)
                                      (split-window-right)
                                      (windmove-right)))               ; was unused
  (define-key evil-window-map "/" '(lambda ()
                                     (interactive)
                                     (split-window-below)
                                     (windmove-down)))               ; was unused

     ;;;
     ;;; Evil Insert state map
     ;;;
  (general-define-key
   :states 'insert
   "C-a" 'crux-move-beginning-of-line ; replaces evil-paste-last-insertion
   "C-e" 'move-end-of-line            ; replaces evil-copy-from-below
   "C-h" 'evil-shift-right-line       ; also bound to C-t
   "C-k" 'kill-line                   ; I don't care about inserting digraphs in insert mode.
   "C-l" 'recenter-top-bottom         ; I find this handy in insert mode
   )

     ;;;
     ;;; Evil Normal state map
     ;;;
  (general-define-key
   :states 'normal
   ;; run the macro in the q register
   "Q" "@q"
   "U" 'undo-tree-redo
   "Y" "yg_"
   )

  ;; Some easy window moving keys
  ;; Thrs Nov 22 2018 9:54:34 - for some reason I had to use the define-key mapping scheme in order to
  ;; get this to work(?)
  (global-unset-key  (kbd "C-j"))
  (global-unset-key  (kbd "C-k"))
  (global-unset-key  (kbd "C-l"))
  ;; (global-unset-key (kbd "C-h"))
  (define-key evil-normal-state-map (kbd "C-j") 'windmove-down)
  (define-key evil-normal-state-map (kbd "C-k") 'windmove-up)
  (define-key evil-normal-state-map (kbd "C-h") 'windmove-left)
  (define-key evil-normal-state-map (kbd "C-l") 'windmove-right)

     ;;;
     ;;; Evil visual state map
     ;;;

  ;; Indent visually.
  (define-key evil-visual-state-map (kbd "<") (lambda ()
                                                (interactive)
                                                (evil-shift-left (region-beginning) (region-end))
                                                (evil-normal-state)
                                                (evil-visual-restore)))
  (define-key evil-visual-state-map (kbd ">") (lambda ()
                                                (interactive)
                                                (evil-shift-right (region-beginning) (region-end))
                                                (evil-normal-state)
                                                (evil-visual-restore)))

     ;;;
     ;;; Leader keys
     ;;;
  (general-create-definer my-leader-def
    ;; :prefix my-leader
    :prefix "SPC")

  (my-leader-def 'normal 'override
    "c" 'hydra-cee/body
    "f" 'hydra-files-projectile/body
    "i" 'helm-mini
    "k" 'flex//kill-current-buffer
    "q" 'save-buffers-kill-terminal
    "r" 'counsel-rg
    "s" 'swiper
    "v" 'hydra-version-control/body
    "w" 'save-buffer
    )

     ;;;
     ;;; 'jk' binding
     ;;;
  (key-chord-define-global "jk" 'hydra-jk/body)

  ;; Moved to here so that all of the bindings are picked up.
  (which-key-mode t)
#+END_SRC

* Notes
** New plugins to Investigate
*** helpful
https://github.com/Wilfred/helpful

*** pcre2el
;; pcre2el
;; https://github.com/joddie/pcre2el/tree/0b5b2a2c173aab3fd14aac6cf5e90ad3bf58fa7d
;; Work with regex in emacs.
;(use-package pcre2el
;  :commands rxt-quote-pcre)

*** List of "good" configurations:
https://github.com/caisah/emacs.dz

** Fixes, workarounds and improvements
*** wrap around backward-kill-word to kill-region & sp-kill-region

 Currently <delete> will kill a region, should make other things do so
 as well, e.g. C-w

*** create a hydra for scrolling other window
    bind it to something available in evil-window-map

 scroll up
 scroll down
 scroll left
 scroll right

scroll-other-window-down will actually scroll the window up ... Emacs
scroll-other-window scrolls down

*** Org mode + Evil rebinds C-j & C-k
 move these to s-j & s-k -> Super key bindings
*** shell-pop vs. multi-term vs. multi-run
    which one, which one to run a terminal in Emacs
*** make following links work in Orgmode
 gx doesn't seem to work
 ace-link-org doesn't work either
*** after +version-control@git-gutter, how do I get back to where I was?
 C-o doesn't help here.
*** why is company interfering with normal completion??
 C-n isn't working with Company
*** PlantUML (sequence diagrams) in Orgmode
http://www.alvinsim.com/diagrams-with-plantuml-and-emacs/
https://joppot.info/en/2017/10/30/4107
*** ivy or helm completion for hl-todo
The following is a Helm example - it finds examples, it just doesn't go to them...

(defun helm-hl-todo-items ()
  (interactive)
  "Show `hl-todo'-keyword items in buffer."
  (helm :sources (helm-build-in-buffer-source "hl-todo items"
                   :init (lambda ()
                           (with-current-buffer (helm-candidate-buffer 'global)
                             (insert (with-helm-current-buffer (buffer-string)))
                             (goto-char (point-min))
                             (delete-non-matching-lines hl-todo--regexp)))
                   :get-line #'buffer-substring)
        :buffer "*helm hl-todo*"))

*** j binding in magit-todos

The default =j <char>= binding needs to be removed

** Reference
    ** byte compile files
 C-x d mydir/predictive RET  ;; Open the predictive directory in Dired.
  % m \.el$ RET               ;; Marks all .el files.
  B                           ;; Byte compiles all marked files. Answer `y' at the prompt.

*** Tail a remote file
 /ssh:root@10.0.6.130:/var/log/hydra.log
 M-x auto-revert-tail-mode

*** Tramp
 HOW TO USE TRAMP IN EMACS TO OPEN A FILE?
 Simply type Ctr-x Ctr-f. You will be prompted for file-name:

 Find file: /home/ (or similiar)

 Suppose you are going to use a ssh-connection, type something like this:

 Find file: /ssh:username@myhost.world.univ:filename

 AUTO-SAVE AND BACKUP
 Set tramp-auto-save-directory.
 Set backup-directory-alist to nil or turn off backup-directory-alist for tramp:

  (require 'tramp)
      (add-to-list 'backup-directory-alist
                   (cons tramp-file-name-regexp nil))

*** Windows Hints
 1. Many things don't like spaces in the path names when building,
    sourcing
 2. When using TRAMP to open remote Linux/Unix files do the following
    (making sure that PuTTY is in the PATH variable):
 Ctrl-x,Ctrl-f
 /plink:ebodine@10.0.11.189:~/test.org

*** Get Alt key to work in emacs/ubuntu

 Enable Alt Key in Xterm

 Normally, if you try the key sequence Alt+1 in xterm, it will output a special
 character. To enable the Alt key:

 Add the following to the .inputrc file in your home directory. Create one if it
 doesn’t exist already.

 set meta-flag on
 set convert-meta off
 set output-meta on

 Add the following to the .Xdefaults file in your home directory.

 XTerm*metaSendsEscape: true
 XTerm*eightBitInput: false

 Open xterm if its not already, and execute the following command in the xterm
 Window.

 xrdb -load ~/.Xdefaults

 Restart all xterm windows. The Alt key should work now.qq




